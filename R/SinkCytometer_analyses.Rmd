---
title: "SinkCytometer_analyses"
output: html_notebook

Authors: Maximilian Berthold, Rahel Vortmeyer-Kley

---

#Below are the parameters for the data import of the Cytometer data.

```{r}

Project <- "PhytoSink"
FP1 <- ".."
PlotFolder <- "Plots"
DataIn <- "TidyData"
DataOut <- "ModelData"
FileID <- "sink"

```

#Packages needed.

```{r load libraries,  message = FALSE, warning = FALSE, echo=FALSE}

library(tidyverse)
library(lubridate)
library(stringr)
library(broom)
library(knitr)
library(OneR)
library(zoo) #creation of time series objects
library(timetk)
library(xts) #creation of time series objects
library(strucchange) #breakpoint analyses
library(changepoint) #changepoint analyses
library(chngpt) #changepoint analyses
library(segmented) #breakpoint analyses
library(googledrive)
library(googlesheets4)
library(rhdf5)
library(minpack.lm)
library(nlstools)
library(nlsMicrobio)
#library(signal) #package containing Savitzky-Golay smoothing filter
  
```

#Loading in the other data frames needed for joining.

``` {r data import}

ImportSink <- readRDS(file = file.path(paste(FP1, DataIn, sep = "/"), paste(Project, FileID, "PicoData.Rds", sep  = "_"),fsep = .Platform$file.sep)) 
MetaData <- read_sheet("https://docs.google.com/spreadsheets/d/1jBRuKWXGL9MDtD3e_NGhhrhWPrB0OdJ8XmJRKQrg0Oo/edit#gid=0")
SinkProt <- read_sheet("https://docs.google.com/spreadsheets/d/1ya-DkakngUYXZce1Ty0l2oX5AvULkLLayoCAgkSexRs/edit?pli=1#gid=0") %>%
  mutate(date_sink = ymd(date_sink))

```


``` {r wholesome individual approach, warning = FALSE}
CapArea_mm2 <- 0.48 #captured area based on MD Pico software
RelTotArea <- 0.0141 #relative area per well in percent based on MD Pico software
TotArea_mm2 <- CapArea_mm2/RelTotArea


SinkMeta <- MetaData %>%
  full_join(SinkProt, by = c("id" = "culture_ID", "strain" = "strain", "plate" = "plate_origin", "well" ="well_source")) %>%
  select(-c(id, well, well_target, PropidiumIod_vol_uL)) %>% #unselect Propidium iodide here, as there was a pipetting error once! Calculate true cellcount before that step!!!
  mutate(exp_date = ymd(exp_date))
  
SinkCC <- ImportSink %>%
  select(strain, date_sink, datetime, par_ue, ElapMin, TimeID, well, well_target, CorrDeadCells, AliveCells, DeadAliveCells, TotCy5Cells, culture_vol_uL, PropidiumIod_vol_uL) %>%
  full_join(SinkMeta) %>%
  distinct() %>%
  group_by(strain, date_sink, par_ue, well) %>%
  dplyr::filter(date_sink != "2022-10-20") %>% #data for 20th October currently lost, filter for empty entry
  drop_na(project_id) %>%
  mutate(
         sink_hour = datetime + minutes(ElapMin),
         sink_hour = replace(sink_hour, is.na(sink_hour), datetime)
         ) %>%
  pivot_longer(cols = c(CorrDeadCells, AliveCells, DeadAliveCells, TotCy5Cells), names_to = "Viability", values_to = "Cellcount") %>%
  mutate(Cellcount_L = ((Cellcount/CapArea_mm2)*TotArea_mm2)*100000/(PropidiumIod_vol_uL/culture_vol_uL)) %>% #CellCount per L, 10 µL added each time represents cells per 10 µL times 100 000 per L; factor PropidiumIod/culture_vol represents dilution before start of the experiment
  group_by(strain, date_sink, par_ue, well, Viability) %>%
  mutate(GroupID = cur_group_id()) %>%
  arrange(GroupID) 


opt_bpts <- function(x) { #function to determine optimal amount of breaking points in a time series
  #x = bpts_sum$RSS["BIC",]
  n <- length(x)
  lowest <- vector("logical", length = n-1)
  lowest[1] <- FALSE
  for (i in 2:n) {
    lowest[i] <- x[i] < x[i-1] & x[i] < x[i+1]
  }
  out <- as.integer(names(x)[lowest])
  return(out)
} #https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/


SinkBreak <- SinkCC %>%
  ungroup() %>%
  mutate(Cellcount_L = replace(Cellcount_L, is.na(Cellcount_L), 0)) %>%# replace NAs in Cellcount_L with 0 just for breakpoint analyses
  select(GroupID, Cellcount_L, sink_hour) %>%
  group_by(GroupID) %>%
  nest() %>%
  mutate(ts = map(.x = data, 
                  .f = tk_ts, 
                  select = -sink_hour),
         bp_ts = map(ts, ~breakpoints(formula = Cellcount_L ~ 1, data = .)),
         bpts_sum = map(bp_ts, ~summary(.x)),
         opt_brks = map(bpts_sum, ~opt_bpts(.x$RSS["BIC",]))) %>%
  unnest_wider(opt_brks) %>%
  rename("opt_brks" = "...1") %>%
  mutate(opt_brks = replace(opt_brks, is.na(opt_brks), 0))

  
Mbrk = matrix(data = NA, nrow = nrow(SinkBreak), ncol = 6)

for (i in 1:nrow(SinkBreak)){
  Mbrk[i,1] = i # column 1 is Group ID
}


  for (i in 1:nrow(SinkBreak)){
      for (j in 1:length(SinkBreak[[4]][[i]][["breakpoints"]])) {
        Mbrk[i,j+1] <- SinkBreak[[4]][[i]][["breakpoints"]][[j]]
      }
  } #for-loop code by Rahel

impute.mean <- function(x) replace(x, is.na(x), mean(x, na.rm = TRUE)) #https://stackoverflow.com/questions/9322773/how-to-replace-na-with-mean-by-group-subset

df_brkpt <- as.data.frame(Mbrk) %>%
  rename("GroupID" = "V1", "Brkpt_1" = "V2", "Brkpt_2" = "V3", "Brkpt_3" = "V4", "Brkpt_4" = "V5", "Brkpt_5" = "V6") %>% 
  pivot_longer(cols = c(Brkpt_1:Brkpt_5), values_to = "TimeID", names_to = "BrkptNo") 

df_strain <- SinkCC %>%
  ungroup() %>%
  select(Viability, GroupID, strain, date_sink, par_ue) %>%
  distinct()

impute_brkpt1 <- full_join(df_brkpt, df_strain) %>%
  group_by(Viability, par_ue, strain) %>%
  filter(BrkptNo == "Brkpt_1") %>%
  mutate(
         TimeID = if_else(is.na(TimeID), impute.mean(TimeID), TimeID),
         Brkpt1Av = mean(TimeID),
         TimeID = if_else(TimeID >= 1.5*Brkpt1Av, Brkpt1Av, TimeID),
         TimeID = round(TimeID)
         ) %>%
  select(-Brkpt1Av)

impute_brkpt <- full_join(df_brkpt, df_strain) %>%
  group_by(Viability, par_ue, strain) %>%
  filter(BrkptNo != "Brkpt_1") %>%
  rbind(impute_brkpt1) %>%
  arrange(GroupID,BrkptNo)

Brk_Compare <- full_join(SinkCC, impute_brkpt) %>%
  group_by(GroupID, Viability) %>%
  arrange(GroupID) %>%
  separate(BrkptNo, into = c("Brkpt", "BrkptNo"), sep = "_") %>%
  mutate(BrkTime = case_when(BrkptNo != "NA" ~ ElapMin*1),
         BrkTime = replace(BrkTime, is.na(BrkTime), 0),
         BrkptNo = as.numeric(BrkptNo)) %>%
  fill(BrkptNo, .direction = "up") %>%
  mutate(Cellcount = replace(Cellcount, is.na(Cellcount), 0), # replace NA with 0, as nothing was detected
         CellcountStep = cummax(Cellcount), #https://stackoverflow.com/questions/64029692/ifelse-replace-value-if-it-is-lower-than-previous
         CellcountDiff = CellcountStep - lag(CellcountStep),
         BrkptNo = if_else(BrkptNo > 1, 2, 1)) %>% #sort breaking points into pre-colony sinking breakpoint-period 1, and post-colony as breakpoint-period 2 
  group_by(strain, GroupID, Viability, BrkptNo) %>% #explicitly group to calculate peak-filter based on peak height twice standard deviation
  mutate(CellcountDiffSD = sd(CellcountDiff, na.rm = TRUE),
         CellcountDiffSDFlag = if_else(CellcountDiff >= 2*CellcountDiffSD, 1, 0),
         CellcountMax = if_else(CellcountDiff >= 2*CellcountDiffSD, as.numeric(CellcountDiff), 0),
         BrkTime_test = if_else(CellcountMax > 0, ElapMin, BrkTime),
         tot_vol_uL = added_culture_uL + media_vol_uL,
         well_radius_mm = case_when(plate_type == "Greiner655090" ~ 3.29),
         sink_height_mm = tot_vol_uL/(pi*well_radius_mm^2),
         sink_vel_mm_min = sink_height_mm/BrkTime_test
         )
         
BrkSink <- Brk_Compare %>%
  filter(
         #strain == "CCMP1335",
         sink_vel_mm_min != Inf,
         CellcountDiffSDFlag != 0,
         BrkptNo == 1,
         Viability == "AliveCells",
         sink_vel_mm_min < 0.4
         ) %>%
  drop_na(BrkptNo) %>%
  #        #BrkptNo == "Brkpt_1") %>%
  ggplot(aes(y = sink_vel_mm_min, x = sink_hour, color = as.factor(well))) +
  geom_point() +
  #geom_line(aes(y = sink_vel_mm_min, x = sink_hour, color = as.factor(well))) +
  #geom_point(aes(y = (CCDiffNoNoise), x = ElapMinAv, color = "red")) +
  #geom_smooth(method = "loess", se=FALSE, color="black", formula = y ~ x) +
  #geom_vline(aes(xintercept = CCDiffNoNoise)) +
  #geom_vline(aes(xintercept = BrkTime_test, color = as.factor(date_sink))) +
  facet_grid(
     rows = vars(strain),
    cols = vars(par_ue)
    ) +
  coord_cartesian(
    #xlim = c(0, 0.4)
                   ylim = c(0, 0.5)
                   ) +
  theme_bw()
BrkSink

SinkSizeTotArea <- ImportSink %>%
  select(date_sink, TimeID, well_target, well, strain, par_ue, Cy5TotArea, DeadTotArea, DeadAliveCTotArea) %>%
  rename("AliveCells" = 'Cy5TotArea', 'CorrDeadCells' = 'DeadTotArea', 'DeadAliveCells' = 'DeadAliveCTotArea') %>%
  pivot_longer(cols = c(AliveCells, CorrDeadCells, DeadAliveCells), names_to = "Viability", values_to = "TotCellArea")

SinkSize <- ImportSink %>%
  select(date_sink, TimeID, well_target, well, strain, par_ue, Cy5AvArea, DeadAvArea, DeadAliveCAvArea) %>%
  rename("AliveCells" = 'Cy5AvArea', 'CorrDeadCells' = 'DeadAvArea', 'DeadAliveCells' = 'DeadAliveCAvArea') %>%
  pivot_longer(cols = c(AliveCells, CorrDeadCells, DeadAliveCells), names_to = "Viability", values_to = "AvCellArea") %>%
  full_join(SinkSizeTotArea) %>%
  mutate(AvCellArea = replace(AvCellArea, is.na(AvCellArea), 0),
         TotCellArea = replace(TotCellArea, is.na(TotCellArea), 0)) %>%
  full_join(Brk_Compare) %>%
  group_by(date_sink, Viability, strain, par_ue, well) %>%
  mutate(CellcountDiff = replace(CellcountDiff, is.na(CellcountDiff), 0),
         CellcountDiff = if_else(CellcountDiff > lag(CellcountDiff), as.numeric(CellcountDiff), 0),
         TotCellArea = if_else(TotCellArea > lag(TotCellArea), as.numeric(TotCellArea), 0),
         AvCellSurfDiff = (TotCellArea - lag(TotCellArea))/(CellcountDiff - lag(CellcountDiff)),  #create change in cell surface area between time points
         AvCellSurfDiff = replace(AvCellSurfDiff, is.na(AvCellSurfDiff), 0),
         AvCellSurfDiff = replace(AvCellSurfDiff, is.infinite(AvCellSurfDiff), 0),
         AvCellSurfDiff = replace(AvCellSurfDiff, is.nan(AvCellSurfDiff), 0),
         CellRadius = (2*(sqrt(AvCellSurfDiff/pi)))
         ) %>%
  filter(AvCellSurfDiff > 0)


SinkSizePlot <- SinkSize %>% 
  filter(
         #strain == "CCMP836",
         CellRadius < 100,
         sink_vel_mm_min != Inf,
         CellcountDiffSDFlag != 0,
         #par_ue == 30,
         #date_sink == "2022-10-17",
         #well == 'A2'
         #CellAreaScale >= 0,
         #CellAreaScale <= 1,
         BrkptNo == 1,
         #Viability == "CorrDeadCells",
         #sink_vel_mm_min < 0.4
         ) %>%
  #drop_na(BrkptNo) #%>%
  #        #BrkptNo == "Brkpt_1") %>%
  ggplot(aes(y = (sink_vel_mm_min), x = (CellRadius), color = as.factor(strain))) +
  geom_point() +
 #  geom_point(aes(y = sink_vel_mm_min/100, color = "SinkVeloc"), data = SinkSize) +
 #  scale_y_continuous(
 # # labels = number_format(scale = 1e-3),
 #  sec.axis = sec_axis(trans = ~ .x / 100
 #                      )) +
  geom_smooth(method = "lm",  formula = y ~ 0 + x, se=TRUE, color = "black") +
  facet_grid(
     rows = vars(Viability),
    cols = vars(par_ue)
    ) + 
  #ylim(0, 1000) +
  theme_bw()
SinkSizePlot

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project, "CellRadius", "SinkVeloPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = SinkSizePlot, height = 10, width = 12)
# ExportSize <- SinkSize %>%
#   dplyr::filter(
#          strain %in% c("CCMP1335")
#          ) %>%
#   select(ElapMin, Viability, par_ue, strain, sink_hour, date_sink, AvCellArea, TotCellArea, Cellcount, well, sink_vel_mm_min)
# 
# h5write(ExportSize, "ExportSize_sink.h5", name = "CCMP1335")

```


``` {r growth rates based on cell counts}
#grouping variables for rows & columns, and for nesting for fitting
RowVar <- "par_ue" 
RowVar2 <- "date_sink"
ColVar <- "strain"
ColVar2 <- "Viability"
FitVar <- "Cellcount_L"


GrowthCC <- SinkCC %>%
  group_by(GroupID, date_sink, strain, par_ue, Viability, well, datetime) %>%
  filter(Cellcount_L == max(Cellcount_L, na.rm = TRUE)) %>%
  distinct(GroupID, Cellcount_L) %>%
  full_join(MetaData) %>% 
  ungroup() %>%
  mutate(strain = as.factor(strain)) %>%
  group_by(strain, well, par_ue) %>%
  mutate(logFitVarminFitVar = log(!!sym(FitVar)/min(!!sym(FitVar), na.rm = TRUE)), 
         E_hours = as.numeric((datetime - datetime[1])/3600),
         E_days = as.numeric((datetime - datetime[1])/86400),
         logFitVarminFitVar = replace(logFitVarminFitVar, is.infinite(logFitVarminFitVar), NA)
         ) %>%
  group_by(!!sym(RowVar), !!sym(ColVar), !!sym(ColVar2), well) %>%
  mutate(LagSeed = E_days[which.min(!!sym(FitVar))])

GrowthCC %>%
  #filter(strain %in% "CZS25K") %>%
  filter(Viability %in% "CorrDeadCells") %>%
  #filter(exp_date == "20200902") %>%
  #filter(tissue_treated_plate == TissueTreated) %>%
  #filter(media == Media) %>%
  #filter(SourceSal == source_salinity) %>%
  ggplot()+
  geom_point(aes(x = E_days, y = log(!!sym(FitVar)), colour = as.factor(well), shape = as.factor(!!sym(ColVar2)))) +
  geom_line(aes(x = E_days, y = log(!!sym(FitVar)), colour = as.factor(well), shape = as.factor(!!sym(ColVar2)))) +
  #coord_cartesian(ylim = c(0, 2)) +
  facet_grid(cols = vars(!!sym(ColVar)), rows = vars(!!sym(RowVar))) +
  theme_bw() 

#Define equations as functions.
#x will be taken from 'E_days' when we run the fit.
LogisticEqn <-  function(x, Pmax, Mu, Intercept){(Pmax*Intercept*exp(Mu*x))/(Pmax + (Intercept*(exp(Mu*x)-1)))
}

ModGompertzEqn <- function(x, Gmax,Gmu,Lag){(Gmax*(exp(-exp((Gmu*exp(1))/Gmax*(Lag-x)+1))))}

possibnlSLM = possibly(.f = nlsLM, otherwise = NULL)

#run nesting by passing in values of variables set at top; 
#!!sym(... allows nest to access the characters of the values passed in
GrowthNestSpecific <- GrowthCC %>%
  nest(data = -c(!!sym(RowVar), !!sym(ColVar), !!sym(ColVar2), well, LagSeed))



#extract nest-specific start, lower & upper setting by passing in "."
CellMuSpecific <- GrowthNestSpecific %>% 
    mutate(
  FitLog = map(data, ~possibnlSLM(!!sym(FitVar) ~ LogisticEqn(x = E_days, Intercept, Mu, Pmax),
                            data = .x, 
                            start = list(
                              Intercept = min(.[,FitVar], na.rm = TRUE), 
                              Mu = (log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days), 
                              Pmax = max(.[,FitVar], na.rm = TRUE)),
                            control = list(maxiter = 1000)
                            ,
                            lower = c((min(.[,FitVar], na.rm = TRUE) * 0.05),
                                      ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) *0.05,
                                      ((max(.[,FitVar], na.rm = TRUE)) * 0.05)),
                            upper = c((min(.[,FitVar], na.rm = TRUE) * 10000),
                                      ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) * 10000,
                                      ((max(.[,FitVar], na.rm = TRUE)) * 10000))
               )
                ),
  PredictLog = map(FitLog, augment),
  TidiedLog = map(FitLog, tidy),
  ParamLog = map(FitLog, glance)
  ) %>%
   mutate(
    FitGompertz = (map(data, ~possibnlSLM(logFitVarminFitVar ~ ModGompertzEqn(x = E_days, Lag, Gmu, Gmax),
                                    data = .x,
                                    start = list(Lag = LagSeed, Gmu = (log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days), Gmax = max(.[, "logFitVarminFitVar"], na.rm = TRUE)),
                                    control = list(maxiter = 1000)
                            ,
                                    lower = c(0, ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) * 0.05, max(.[, "logFitVarminFitVar"], na.rm = TRUE) * 0.05),
                                    upper = c(1000, ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) * 10000, max(.[, "logFitVarminFitVar"], na.rm = TRUE) * 10000)))),
    PredictGompertz = map(FitGompertz, augment),
    TidiedGompertz = map(FitGompertz, tidy),
    ParamGompertz = map (FitGompertz, glance))

CellLogSpecificPredict <- CellMuSpecific %>%
  unnest(PredictLog)

CellLogSpecificCoeff <- CellMuSpecific %>% 
  unnest(TidiedLog) %>%
  dplyr::select(c(!!sym(RowVar), !!sym(ColVar), !!sym(ColVar2), well, term:p.value)) 

CellGompertzSpecificPredict <- CellMuSpecific %>%
  unnest(PredictGompertz)

CellGompertzSpecificCoeff <- CellMuSpecific %>% 
  unnest(TidiedGompertz) %>%
  dplyr::select(c(!!sym(RowVar), !!sym(ColVar), !!sym(ColVar2), well, term:p.value)) 

CellLogSpecificPlot <- CellLogSpecificPredict %>% 
  ggplot() +  
  geom_line(aes(x = E_days, y = log(.fitted), color = as.factor(Viability)), size = 0.5) +
  geom_point(aes(x = E_days, y = log(!!sym(FitVar)), color = as.factor(Viability)), size = 0.6) +
  # geom_ribbon(aes(x = E_days, ymin = (.fitted - .resid), ymax = (.fitted + .resid), alpha = 0.1),show.legend = FALSE) +
  facet_grid(cols = vars(strain), rows = vars(par_ue)) +
  theme_bw() #+
  #theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour = "black")) +
  #labs(y = expression(paste("log(OD"[`680 nm`]*"/min OD"[`680 nm`]*")")), x = "Elapsed time (h)", title = "Treatment Growth, Modified Gompertz with Lag", subtitle = paste(str_c(Strains, collapse = "_"), str_c(StartDate, collapse = "_")))
  # labs(y = FitVar,
  #      title = "Treatment Growth, Specific Log",
  #      subtitle = paste(nm_filter, "nm", str_c(Strains, collapse = "_"), str_c(StartDate, collapse = "_")),
  #       legend.position="top",
  #     legend.text=element_text(size=20),
  #     legend.title =element_text(size=20),
  #      caption = "Log")

CellLogSpecificPlot

CellGompertzLagSpecificPlot <- CellGompertzSpecificPredict %>% 
  ggplot() +  
  geom_line(aes(x = E_days, y = .fitted, color = as.factor(Viability)), size = 0.5) +
  geom_point(aes(x = E_days, y = logFitVarminFitVar, color = as.factor(Viability)), size = 0.6) +
  # geom_ribbon(aes(x = E_days, ymin = (.fitted - .resid), ymax = (.fitted + .resid), alpha = 0.1),show.legend = FALSE) +
  facet_grid(cols = vars(strain), rows = vars(par_ue)) +
  theme_bw() 
  #theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour = "black")) +
  #labs(y = expression(paste("log(Cells"[`750 nm`]*"/min Cells"[`750 nm`]*")")), x = "Elapsed time (d)", title = "Modified Gompertz with Lag") +
  #scale_y_continuous(sec.axis = sec_axis(~ . , name = "Growth level (µmol " ~ m^-2 ~s^-1~" )", breaks = seq(0,10, by=5), labels = NULL))+
  # theme( legend.position="top",
  #     legend.text=element_text(size=20),
  #     legend.title =element_text(size=20),
  #     axis.text.x=element_text(angle=30, hjust = 1, size=7))
  # labs(y = FitVar,
  #      #title = "Treatment Growth, Modified Gompertz Specific with Lag",
  #      subtitle = paste(nm_filter, "nm", str_c(Strains, collapse = "_"), str_c(StartDate, collapse = "_")),
  #      #caption = "Modified Gompertz with Lag Line"
  #      )

CellGompertzLagSpecificPlot

CellLogSpecificCoeff %>% 
  filter(term == "Mu") %>%
  ggplot() +  
  #geom_line(aes(x = par_ue, y = estimate, color = as.factor(well)), size = 0.5) +
  geom_point(aes(x = par_ue, y = estimate, color = as.factor(well)), size = 1) +
  # geom_ribbon(aes(x = E_days, ymin = (.fitted - .resid), ymax = (.fitted + .resid), alpha = 0.1),show.legend = FALSE) +
  facet_grid(cols = vars(strain), rows = vars(Viability)) +
  ylim(0, 3) +
  theme_bw() 

```



``` {r growth rate based on Chlorophyll extraction} 
#grouping variables for rows & columns, and for nesting for fitting
RowVar <- "par_ue" 
RowVar2 <- "date_sink"
ColVar <- "strain"
FitVar <- "Chl_ugL_mean"

ChloroGoogle <- "https://docs.google.com/spreadsheets/d/1OaOGZe5qMB_C0b82PTQMRRC0EbRwAH3RCsdYObSfQ7c/edit#gid=0"
gs4_deauth()
ChloroData <- read_sheet(ChloroGoogle)

ChlFluor <- ChloroData %>%
  mutate(ChlDateTime = ymd_hms(paste(DATE, TIME))) %>%
  rename(date_sink = DATE, ObsTime = TIME, id = CultureID) %>%
  mutate(date_sink = ymd(date_sink)) %>%
  mutate(Chl_dil = (Reading_rfu - Chl_intercept)/Chl_slope,
         Chl_ugL = Chl_dil * ((SolventVol_ul + SampleVol_ul)/SampleVol_ul)) %>%
  group_by(id, date_sink) %>%
  summarize (Chl_ugL_mean = mean(Chl_ugL, na.rm = TRUE), .groups = "keep") %>%
  ungroup() %>%
  filter(Chl_ugL_mean > 0) %>%
  full_join(MetaData, by = c("id" = "id")) %>% 
  drop_na(Chl_ugL_mean, project_id)
ChlFluor


ChlFluor %>%
  #filter(strain %in% "CZS25K") %>%
  #filter(exp_date == "20200902") %>%
  #filter(tissue_treated_plate == TissueTreated) %>%
  #filter(media == Media) %>%
  #filter(SourceSal == source_salinity) %>%
  ggplot()+
  geom_point(aes(x = date_sink, y = Chl_ugL_mean, colour = as.factor(well))) +
  geom_line(aes(x = date_sink, y = Chl_ugL_mean, colour = as.factor(well))) +
  #coord_cartesian(ylim = c(0, 2)) +
  facet_grid(cols = vars(strain), rows = vars(par_ue)) +
  theme_bw() 

GrowthCellChl <- full_join(ChlFluor, GrowthCC) %>%
  group_by(!!sym(RowVar), !!sym(ColVar),  well) %>%
  mutate(LagSeed = E_days[which.min(!!sym(FitVar))]) %>%
  filter(Viability == "TotCy5Cells") #track growth based on all Chl-fluorescing cells, dead or DeadAlive
 
#Define equations as functions.
#x will be taken from 'E_days' when we run the fit.
LogisticEqn <-  function(x, Pmax, Mu, Intercept){(Pmax*Intercept*exp(Mu*x))/(Pmax + (Intercept*(exp(Mu*x)-1)))
}

ModGompertzEqn <- function(x, Gmax,Gmu,Lag){(Gmax*(exp(-exp((Gmu*exp(1))/Gmax*(Lag-x)+1))))}

possibnlSLM = possibly(.f = nlsLM, otherwise = NULL)

#run nesting by passing in values of variables set at top; 
#!!sym(... allows nest to access the characters of the values passed in
ChlNestSpecific <- GrowthCellChl %>%
  nest(data = -c(!!sym(RowVar), !!sym(ColVar), well, LagSeed))



#extract nest-specific start, lower & upper setting by passing in "."
ChlMuSpecific <- ChlNestSpecific %>% 
    mutate(
  FitLog = map(data, ~possibnlSLM(!!sym(FitVar) ~ LogisticEqn(x = E_days, Intercept, Mu, Pmax),
                            data = .x, 
                            start = list(
                              Intercept = min(.[,FitVar], na.rm = TRUE), 
                              Mu = (log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days), 
                              Pmax = max(.[,FitVar], na.rm = TRUE)),
                            control = list(maxiter = 1000)
                            ,
                            lower = c((min(.[,FitVar], na.rm = TRUE) * 0.05),
                                      ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) *0.05,
                                      ((max(.[,FitVar], na.rm = TRUE)) * 0.05)),
                            upper = c((min(.[,FitVar], na.rm = TRUE) * 10000),
                                      ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) * 10000,
                                      ((max(.[,FitVar], na.rm = TRUE)) * 10000))
               )
                ),
  PredictLog = map(FitLog, augment),
  TidiedLog = map(FitLog, tidy),
  ParamLog = map(FitLog, glance)
  ) %>%
   mutate(
    FitGompertz = (map(data, ~possibnlSLM(logFitVarminFitVar ~ ModGompertzEqn(x = E_days, Lag, Gmu, Gmax),
                                    data = .x,
                                    start = list(Lag = LagSeed, Gmu = (log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days), Gmax = max(.[, "logFitVarminFitVar"], na.rm = TRUE)),
                                    control = list(maxiter = 1000)
                            ,
                                    lower = c(0, ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) * 0.05, max(.[, "logFitVarminFitVar"], na.rm = TRUE) * 0.05),
                                    upper = c(1000, ((log(max(.[, FitVar], na.rm = TRUE)) - log(min(.[ FitVar], na.rm = TRUE)))/max(.$E_days)) * 10000, max(.[, "logFitVarminFitVar"], na.rm = TRUE) * 10000)))),
    PredictGompertz = map(FitGompertz, augment),
    TidiedGompertz = map(FitGompertz, tidy),
    ParamGompertz = map (FitGompertz, glance))

ChlLogSpecificPredict <- ChlMuSpecific %>%
  unnest(PredictLog)

ChlLogSpecificCoeff <- ChlMuSpecific %>% 
  unnest(TidiedLog) %>%
  dplyr::select(c(!!sym(RowVar), !!sym(ColVar),  well, term:p.value)) 

ChlGompertzSpecificPredict <- ChlMuSpecific %>%
  unnest(PredictGompertz)

ChlGompertzSpecificCoeff <- ChlMuSpecific %>% 
  unnest(TidiedGompertz) %>%
  dplyr::select(c(!!sym(RowVar), !!sym(ColVar),  well, term:p.value)) 

ChlLogSpecificPlot <- ChlLogSpecificPredict %>% 
  ggplot() +  
  geom_line(aes(x = E_days, y = log(.fitted), color = as.factor(well)), size = 0.5) +
  geom_point(aes(x = E_days, y = log(!!sym(FitVar)), color = as.factor(well)), size = 0.6) +
  # geom_ribbon(aes(x = E_days, ymin = (.fitted - .resid), ymax = (.fitted + .resid), alpha = 0.1),show.legend = FALSE) +
  facet_grid(cols = vars(strain), rows = vars(par_ue)) +
  theme_bw() #+
  #theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour = "black")) +
  #labs(y = expression(paste("log(OD"[`680 nm`]*"/min OD"[`680 nm`]*")")), x = "Elapsed time (h)", title = "Treatment Growth, Modified Gompertz with Lag", subtitle = paste(str_c(Strains, collapse = "_"), str_c(StartDate, collapse = "_")))
  # labs(y = FitVar,
  #      title = "Treatment Growth, Specific Log",
  #      subtitle = paste(nm_filter, "nm", str_c(Strains, collapse = "_"), str_c(StartDate, collapse = "_")),
  #       legend.position="top",
  #     legend.text=element_text(size=20),
  #     legend.title =element_text(size=20),
  #      caption = "Log")

ChlLogSpecificPlot

ChlGompertzLagSpecificPlot <- ChlGompertzSpecificPredict %>% 
  ggplot() +  
  geom_line(aes(x = E_days, y = .fitted, color = as.factor(well)), size = 0.5) +
  geom_point(aes(x = E_days, y = logFitVarminFitVar, color = as.factor(well)), size = 0.6) +
  # geom_ribbon(aes(x = E_days, ymin = (.fitted - .resid), ymax = (.fitted + .resid), alpha = 0.1),show.legend = FALSE) +
  facet_grid(cols = vars(strain), rows = vars(par_ue)) +
  theme_bw() 
  #theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text = element_text(colour = "black")) +
  #labs(y = expression(paste("log(Cells"[`750 nm`]*"/min Cells"[`750 nm`]*")")), x = "Elapsed time (d)", title = "Modified Gompertz with Lag") +
  #scale_y_continuous(sec.axis = sec_axis(~ . , name = "Growth level (µmol " ~ m^-2 ~s^-1~" )", breaks = seq(0,10, by=5), labels = NULL))+
  # theme( legend.position="top",
  #     legend.text=element_text(size=20),
  #     legend.title =element_text(size=20),
  #     axis.text.x=element_text(angle=30, hjust = 1, size=7))
  # labs(y = FitVar,
  #      #title = "Treatment Growth, Modified Gompertz Specific with Lag",
  #      subtitle = paste(nm_filter, "nm", str_c(Strains, collapse = "_"), str_c(StartDate, collapse = "_")),
  #      #caption = "Modified Gompertz with Lag Line"
  #      )

ChlGompertzLagSpecificPlot

ChlLogSpecificCoeff %>% 
  filter(term == "Mu") %>%
  ggplot() +  
  #geom_line(aes(x = par_ue, y = estimate, color = as.factor(well)), size = 0.5) +
  geom_point(aes(x = par_ue, y = estimate, color = as.factor(well)), size = 1) +
  # geom_ribbon(aes(x = E_days, ymin = (.fitted - .resid), ymax = (.fitted + .resid), alpha = 0.1),show.legend = FALSE) +
  facet_grid(cols = vars(strain), rows = vars(par_ue)) +
  ylim(0, 1) +
  theme_bw() 

test <- full_join(ChlLogSpecificCoeff %>% rename("Chl_estimate" = "estimate") %>% select(-c(std.error, statistic, p.value)), CellLogSpecificCoeff %>% rename("Cell_estimate" = "estimate") %>% filter(Viability %in% c("AliveCells")) %>%select(-c(std.error, statistic, p.value, Viability))) %>%
  filter(term %in% c("Mu")) %>%
  group_by(strain, par_ue) %>%
  mutate(Cell_estimate_av = mean(Cell_estimate),
         Chl_estimate_av = mean(Chl_estimate)) %>%
  ggplot(aes(x = Cell_estimate_av, y = Chl_estimate_av, color = as.factor(par_ue))) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  #coord_cartesian(ylim = c(0, 3), xlim = c(0, 3)) +
  facet_grid(cols = vars(strain)) + 
  theme(aspect.ratio = 1) +
  theme_bw()
test

CellChl <- GrowthCellChl %>%
  filter(Viability %in% "TotCy5Cells") %>%
  mutate(Chl_Cell = Chl_ugL_mean/Cellcount_L*10^6) %>%
  filter(strain %in% "CZS25K")
  ggplot(aes(x = date_sink, y = log(Chl_Cell), color = as.factor(par_ue))) +
  geom_point() +
  #coord_cartesian(ylim = c(0, 3), xlim = c(0, 3)) +
  facet_grid(
            rows = vars(par_ue),
             cols = vars(strain)) + 
  theme(aspect.ratio = 1) +
  theme_bw() 

```



``` {r averaged replicates, warning = FALSE}

SinkReplCCAv <- ImportSink %>%
  group_by(strain, date_sink,datetime, par_ue, ElapMin, TimeID) %>%
  mutate(ReplicateNo = cur_group_id(), 
         DeadAliveCells = replace(DeadAliveCells, is.na(DeadAliveCells), 0),
         AliveCells = replace(AliveCells, is.na(AliveCells), 0),# replace NA with 0, as nothing was detected
         CorrDeadCells = replace(CorrDeadCells, is.na(CorrDeadCells), 0)
         ) %>%
  group_by(ReplicateNo, strain, date_sink, datetime, par_ue, ElapMin, TimeID) %>%
  summarise(DeadAliveCC_repl = mean(DeadAliveCells, na.rm = TRUE),
            AliveCC_repl = mean(AliveCells, na.rm = TRUE),
            DeadCC_repl = mean(CorrDeadCells, na.rm = TRUE)
            ) 

SinkAvShort <- MetaData %>%
  full_join(SinkProt, by = c("id" = "culture_ID", "strain" = "strain", "plate" = "plate_origin", "well" ="well_source")) %>%
  select(-c(id, well, well_target, PropidiumIod_vol_uL)) %>% #unselect Propidium iodide here, as there was a pipetting error once! Calculate true cellcount before that step!!!
  full_join(SinkReplCCAv) %>%
  distinct() %>%
  group_by(strain, date_sink, par_ue) %>%
  mutate(ColonySink = case_when(ElapMin < 120 ~ "Colony",
                                ElapMin > 120 ~ "PostColony"),
         AliveCCStep = cummax(AliveCC_repl),
         DeadCCStep = cummax(DeadCC_repl),
         DeadAliveCCStep = cummax(DeadAliveCC_repl), #https://stackoverflow.com/questions/64029692/ifelse-replace-value-if-it-is-lower-than-previous
         AliveDiff = AliveCCStep - lag(AliveCCStep),
         DeadDiff = DeadCCStep - lag(DeadCCStep), 
         DeadAliveDiff = DeadAliveCCStep - lag(DeadAliveCCStep)
         ) %>%  
  dplyr::filter(date_sink != "2022-10-20")  %>% #data for 20th October currently lost, filter for empty entry
  drop_na(project_id) %>%
      mutate(sink_hour = datetime + minutes(ElapMin),
             GroupID = cur_group_id(),
             sink_hour = replace(sink_hour, is.na(sink_hour), datetime)
         ) %>%
  arrange(GroupID)



SinkAvShort <- MetaData %>%
  full_join(SinkProt, by = c("id" = "culture_ID", "strain" = "strain", "plate" = "plate_origin", "well" ="well_source")) %>%
  select(-c(id, well, well_target, PropidiumIod_vol_uL)) %>% #unselect Propidium iodide here, as there was a pipetting error once! Calculate true cellcount before that step!!!
  full_join(SinkReplCCAv) %>%
  distinct() %>%
  group_by(strain, date_sink, par_ue) %>%
  mutate(ElapMinAv = rollmean(ElapMin, k = 3, fill = NA), #elapsed minute average smooth, k = 3 to align time with smoothed data
         DeadAliveCCAv = rollmean(DeadAliveCC_repl, k = 3, fill = NA), #cell count average, k = 3 as moderate smoother, compared to too noisy or to too much filtering
         DeadAliveDiffAv = DeadAliveCCAv - lag(DeadAliveCCAv), # create cell difference between time steps
         DeadAliveDiffAv = replace(DeadAliveDiffAv, DeadAliveDiffAv < 0, 0), # treat every negative cell difference as 0 == no change to increase positive peak size
         DeadAliveDiffAv = replace(DeadAliveDiffAv, is.na(DeadAliveDiffAv), 0),
         AliveCCAv = rollmean(AliveCC_repl, k = 3, fill = NA), 
         AliveDiffAv = AliveCCAv - lag(AliveCCAv), 
         AliveDiffAv = replace(AliveDiffAv, AliveDiffAv < 0, 0), 
         AliveDiffAv = replace(AliveDiffAv, is.na(AliveDiffAv), 0),
         DeadCCAv = rollmean(DeadCC_repl, k = 3, fill = NA), 
         DeadDiffAv = DeadCCAv - lag(DeadCCAv), 
         DeadDiffAv = replace(DeadDiffAv, DeadDiffAv < 0, 0), 
         DeadDiffAv = replace(DeadDiffAv, is.na(DeadDiffAv), 0)
         ) %>%  
  dplyr::filter(date_sink != "2022-10-20") %>% #data for 20th October currently lost, filter for empty entry
  drop_na(project_id) %>%
      mutate(sink_hour = datetime + minutes(ElapMinAv),
         GroupID = cur_group_id(),
         sink_hour = replace(sink_hour, is.na(sink_hour), datetime)
         ) %>%
  arrange(GroupID)

Cyano <- c("PCC6803", "CZS25K", "CCMP836") #c("CCMP495", "CCMP1335", "CCMP1336")
Diatom <- c("CCMP495", "CCMP1335", "CCMP1336") #, "CCMP1335", "CCMP1336")




opt_bpts <- function(x) {
  #x = bpts_sum$RSS["BIC",]
  n <- length(x)
  lowest <- vector("logical", length = n-1)
  lowest[1] <- FALSE
  for (i in 2:n) {
    lowest[i] <- x[i] < x[i-1] & x[i] < x[i+1]
  }
  out <- as.integer(names(x)[lowest])
  return(out)
} #https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/


TS_brks <- SinkAvShort %>%
  ungroup() %>%
  select(GroupID, CCDiffAv, sink_hour) %>%
  arrange(GroupID) %>%
  group_by(GroupID) %>% nest() %>%
  mutate(ts = map(.x = data, 
                  .f = tk_ts, 
                  select = -sink_hour),
         bp_ts = map(ts, ~breakpoints(formula = CCDiffAv ~ 1, data = .)),
         bpts_sum = map(bp_ts, ~summary(.x)),
         opt_brks = map(bpts_sum, ~opt_bpts(.x$RSS["BIC",]))) %>%
  unnest_wider(opt_brks) %>%
  rename("opt_brks" = "...1") %>%
  mutate(opt_brks = replace(opt_brks, is.na(opt_brks), 0)) 

 
Mbrk = matrix(data = NA, nrow = nrow(TS_brks), ncol = 5)

for (i in 1:nrow(TS_brks)){
  Mbrk[i,1] = i # column 1 is Group ID
}


  for (i in 1:nrow(TS_brks)){
      for (j in 1:length(TS_brks[[4]][[i]][["breakpoints"]])) {
        Mbrk[i,j+1] <- TS_brks[[4]][[i]][["breakpoints"]][[j]]
      }
  } #for-loop code by Rahel

df_brkpt <- as.data.frame(Mbrk) %>%
  rename("GroupID" = "V1", "Brkpt_1" = "V2", "Brkpt_2" = "V3", "Brkpt_3" = "V4", "Brkpt_4" = "V5") %>% 
  pivot_longer(cols = c(Brkpt_1:Brkpt_4), values_to = "TimeID", names_to = "BrkptNo") %>%
  drop_na() 



Brk_Compare <- full_join(SinkAvShort, df_brkpt) %>%
  arrange(GroupID) %>%
  # filter(strain == "CCMP495",
  #        par_ue == 100) 
  mutate(BrkTime = case_when(BrkptNo != "NA" ~ ElapMinAv*1),
         BrkTime = replace(BrkTime, BrkTime == 0, NA),
         CCDiffNoNoise = case_when(CCDiffAv <= StNcc ~ 0,
                                   CCDiffAv > StNcc ~ (CCDiffAv*1)
                                   ),
         CCDiffNoNoise = replace(CCDiffNoNoise, CCDiffNoNoise == 0, NA),
         tot_vol_uL = added_culture_uL + media_vol_uL,
         well_radius_mm = case_when(plate_type == "Greiner655090" ~ 3.29),
         sink_height_mm = tot_vol_uL/(pi*well_radius_mm^2),
         sink_vel_mm_min = sink_height_mm/BrkTime)


#MinFilter <- 120
Y_var <- "CellSurfDiffAv" # TCAreaDiffAv CellSurfDiffAv CCDiffAv
Cyano <- c("PCC6803", "CZS25K", "CCMP836") #c("CCMP495", "CCMP1335", "CCMP1336")
Diatom <- c("CCMP495" , "CCMP1335", "CCMP1336") #, "CCMP1335", "CCMP1336")
  
CyanoSinkAll <- Brk_Compare %>%
  filter(Viability == "AliveCells") %>%
  filter(strain %in% "CCMP495", 
         #Y_var > 0
         ) %>%
  #filter(ElapMinAv < MinFilter) %>%
  ggplot() +
  geom_line(aes(y = (Cellcount), x = ElapMin)) +
  #geom_point(aes(y = (CCDiffNoNoise), x = ElapMinAv, color = "red")) +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  #geom_vline(aes(xintercept = CCDiffNoNoise)) +
  geom_vline(aes(xintercept = BrkTime, color = as.factor(BrkptNo))) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(date_sink)
    ) +
  coord_cartesian(xlim = c(0, 610)
  #                , ylim = c(0, 16)
                  ) +
  theme_bw()
CyanoSinkAll

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project, Y_var, "Cyano", "SinkAvPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = CyanoSinkAll, height = 10, width = 12)

BrkSink <- Brk_Compare %>%
  # filter(strain == "CCMP495") %>%
  # drop_na(BrkptNo)
         #BrkptNo == "Brkpt_1") %>%
  ggplot(aes(y = sink_vel_mm_min, x = date_sink, color = as.factor(BrkptNo))) +
  geom_line() +
  #geom_point(aes(y = (CCDiffNoNoise), x = ElapMinAv, color = "red")) +
  #geom_smooth(method = "loess", se=FALSE, color="black", formula = y ~ x) +
  #geom_vline(aes(xintercept = CCDiffNoNoise)) +
  #geom_vline(aes(xintercept = BrkTime, color = as.factor(date_sink))) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  #coord_cartesian(xlim = c(0, 610)
  #                , ylim = c(0, 16)
  #                ) +
  theme_bw()
BrkSink

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project, "BreakingPointAll_SinkAvPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = BrkSink, height = 10, width = 12)

Strain <- "PCC6803"
test <- SinkAvShort %>%
  group_by(GroupID, ColonySink) %>%
  mutate(AliveDiffSD = sd(AliveDiff, na.rm = TRUE),
         AliveDiffStNFlag = if_else(AliveDiff >= 2*AliveDiffSD , 1, 0),
         DeadDiffSD = sd(DeadDiff, na.rm = TRUE),
         DeadDiffStNFlag = if_else(DeadDiff >= 2*DeadDiffSD , 1, 0),
         DeadAliveDiffSD = sd(DeadAliveDiff, na.rm = TRUE),
         DeadAliveDiffStNFlag = if_else(DeadAliveDiff >= 2*DeadAliveDiffSD , 1, 0),
         AliveMax = if_else(AliveDiff >= 2*AliveDiffSD, AliveDiff, 0),
         DeadMax = if_else(DeadDiff >= 2*DeadDiffSD, DeadDiff, 0),
         DeadAliveMax = if_else(DeadAliveDiff >= 2*DeadAliveDiffSD, DeadAliveDiff, 0),
         Number = ave(AliveMax, FUN = function(G){
  G*(cumsum(G == 0) + (G[1] == 1))
  }),
  DeadRatio = DeadAliveCC_repl/AliveCC_repl
      ) %>%
  #        ) %>% 
  # filter(AliveMax != 0, 
  #        strain %in% Diatom) %>%
  # drop_na(AliveMax) 
  dplyr::filter( 
         #AliveDiffStNFlag == 1,
         # DeadDiffStNFlag == 1,
         # DeadAliveDiffStNFlag == 1,
         strain %in% Strain,
         date_sink != "2022-10-14"
                                    #https://stackoverflow.com/questions/67028230/assign-group-numbers-within-ids-to-rows-separated-by-zeros
         ) %>%
  ggplot(aes(y = AliveCC_repl, x = ElapMin, color = "Alive")) +
  geom_line() +
  # geom_line(aes(y = (DeadAliveCC_repl), x = ElapMin, color = "DeadAlive")) +
  # geom_line(aes(y = (DeadCC_repl), x = ElapMin, color = "Dead")) +
  #geom_point(aes(y = (CCDiffNoNoise), x = ElapMinAv, color = "red")) +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  #geom_hline(aes(yintercept = 2*AliveDiffSD, color = as.factor(ColonySink))) +
  #geom_vline(aes(xintercept = 120)) +
  xlab(bquote("Elapsed time (minutes)")) + 
  ylab(bquote('Cell count (Alive)')) +
  guides(color = guide_legend(title = "Synechocystis sp.")) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "Photon flux rate (µE)", breaks = NULL, labels = NULL)) +
  scale_x_continuous(sec.axis = sec_axis(~ . , name = "Sink date and time", breaks = NULL, labels = NULL)) +
  facet_grid(
    rows = vars(par_ue)
    ,cols = vars(date_sink)
    ) +
  coord_cartesian(xlim = c(0, 610)
                  #, ylim = c(0, 16)
                  ) +
  theme_bw()
test
ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project, Strain, "CellSinkAlive.png", sep = "_"), fsep = .Platform$file.sep), plot = test, height = 10, width = 12)


CellSurfPlot <- SinkAvShort %>%
  group_by(GroupID, ColonySink) %>%
  mutate(AliveDiffSD = sd(AliveDiff, na.rm = TRUE),
         AliveDiffStNFlag = if_else(AliveDiff >= 2*AliveDiffSD , 1, 0),
         DeadDiffSD = sd(DeadDiff, na.rm = TRUE),
         DeadDiffStNFlag = if_else(DeadDiff >= 2*DeadDiffSD , 1, 0),
         DeadAliveDiffSD = sd(DeadAliveDiff, na.rm = TRUE),
         DeadAliveDiffStNFlag = if_else(DeadAliveDiff >= 2*DeadAliveDiffSD , 1, 0)
         ) %>%
  dplyr::filter( 
         #AliveDiffStNFlag == 1,
         # DeadDiffStNFlag == 1,
         # DeadAliveDiffStNFlag == 1,
         strain %in% "CCMP495",
         #date_sink != "2022-10-14"
                                    #https://stackoverflow.com/questions/67028230/assign-group-numbers-within-ids-to-rows-separated-by-zeros
         ) %>%
  ggplot(aes(y = (AliveCC_repl), x = ElapMin, color = "Alive")) +
  geom_line() +
  geom_line(aes(y = (DeadCC_repl), x = ElapMin, color = "Dead")) +
  geom_line(aes(y = (DeadAliveCC_repl), x = ElapMin, color = "DeadAlive")) +
  #geom_point(aes(y = (CCDiffNoNoise), x = ElapMinAv, color = "red")) +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  geom_hline(aes(yintercept = 2*AliveDiffSD, color = as.factor(ColonySink))) +
  geom_vline(aes(xintercept = 120)) +
  facet_grid(
    rows = vars(par_ue)
    ,cols = vars(date_sink)
    ) +
  coord_cartesian(xlim = c(0, 610)
                  #, ylim = c(0, 16)
                  ) +
  theme_bw()
CellSurfPlot



ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project, "CellSurfaceTrend_SinkAvPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = CellSurfPlot, height = 10, width = 12)

```


``` {r post-colony sinking}
TS_brks <- SinkAvShort %>%
  ungroup() %>%
  filter(ElapMinAv > 150) %>%
  select(GroupID, CCDiffAv, sink_hour) %>%
  arrange(GroupID) %>%
  group_by(GroupID) %>% nest() %>%
  mutate(ts = map(.x = data, 
                  .f = tk_ts, 
                  select = -sink_hour),
         bp_ts = map(ts, ~breakpoints(formula = CCDiffAv ~ 1, data = .)),
         bpts_sum = map(bp_ts, ~summary(.x)),
         opt_brks = map(bpts_sum, ~opt_bpts(.x$RSS["BIC",]))) %>%
  unnest_wider(opt_brks) %>%
  rename("opt_brks" = "...1") %>%
  mutate(opt_brks = replace(opt_brks, is.na(opt_brks), 0)) 

 
Mbrk = matrix(data = NA, nrow = nrow(TS_brks), ncol = 5)
for (i in 1:nrow(TS_brks)){
  Mbrk[i,1] = i # column 1 is Group ID
}


  for (i in 1:nrow(TS_brks)){
      for (j in 1:length(TS_brks[[4]][[i]][["breakpoints"]])) {
        Mbrk[i,j+1] <- TS_brks[[4]][[i]][["breakpoints"]][[j]]
      }
  } #for-loop code by Rahel

df_brkpt <- as.data.frame(Mbrk) %>%
  rename("GroupID" = "V1", "Brkpt_1" = "V2", "Brkpt_2" = "V3", "Brkpt_3" = "V4", "Brkpt_4" = "V5") %>% 
  pivot_longer(cols = c(Brkpt_1:Brkpt_4), values_to = "TimeID", names_to = "BrkptNo")%>%
  drop_na() 



Brk_Compare <- full_join(SinkAvShort, df_brkpt) %>%
  arrange(GroupID) %>%
  mutate(BrkTime = case_when(BrkptNo != "NA" ~ ElapMinAv*1),
         BrkTime = replace(BrkTime, BrkTime == 0, NA),
         CCDiffNoNoise = case_when(CCDiffAv <= StNcc ~ 0,
                                   CCDiffAv > StNcc ~ (CCDiffAv*1)
                                   ),
         CCDiffNoNoise = replace(CCDiffNoNoise, CCDiffNoNoise == 0, NA))


MinFilter <- 150
Y_var <- "CCDiffAv" # TCAreaDiffAv CellSurfDiffAv CCDiffAv
Cyano <- c("PCC6803", "CZS25K", "CCMP836") #c("CCMP495", "CCMP1335", "CCMP1336")
Diatom <- c("CCMP495", "CCMP1335", "CCMP1336")#, "CCMP1335", "CCMP1336")
  
CyanoSinkAll <- Brk_Compare %>%
  #filter(date_sink == "2022-10-16") %>%
  filter(strain %in% Diatom, 
         Y_var > 0) %>%
  filter(ElapMinAv > MinFilter) %>%
  ggplot() +
  geom_line(aes(y = (CCAv), x = ElapMinAv, color = as.factor(date_sink))) +
  #geom_line(aes(y = log(!!sym(Y_var)), x = ElapMinAv, color = "CCDiffAv")) +
  #geom_line(aes(y = log(TCAreaDiffAv), x = ElapMinAv, color = "TCAreaDiffAv")) +
  #geom_line(aes(y = log(CellSurfDiffAv), x = ElapMinAv, color = "CellSurfDiffAv")) +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  #geom_vline(aes(xintercept = CCDiffNoNoise)) +
  geom_vline(aes(xintercept = BrkTime, color = as.factor(date_sink))) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  coord_cartesian(xlim = c(0, 610)
                  #, ylim = c(0, 16)
                  ) +
  theme_bw()
CyanoSinkAll

```



``` {r individual replicates}

SinkAll <- ImportSink %>%
  group_by(id, date_sink) %>%
  mutate(cellcount = replace(cellcount, is.na(cellcount), 0), # replace NA with 0, as nothing was detected
         TotalCellArea = replace(TotalCellArea, is.na(TotalCellArea), 0), # replace NA with 0, as nothing was detected
         CCAv = rollmean(cellcount, k = 3, fill = NA), #cell count average, k = 3 as moderate smoother, compared to too noisy or to too much filtering
         TCAreaAv = rollmean(TotalCellArea, k = 3, fill = NA), #total cell area average smooth, k = 3
         ElapMinAv = rollmean(ElapMin, k = 3, fill = NA), #elapsed minute average smooth, k = 3 to align time with smoothed data
         CCDiffAv = CCAv - lag(CCAv), # create cell difference between time steps
         CCDiffAv = replace(CCDiffAv, CCDiffAv < 0, 0), # treat every negative cell difference as 0 == no change to increase positive peak size
         CCDiffAv = replace(CCDiffAv, is.na(CCDiffAv), 0),
         CellSurfDiffAv = (TCAreaAv-lag(TCAreaAv))/(CCAv-lag(CCAv)), # create change in cell surface area between time points
         CellSurfDiffAv = replace(CellSurfDiffAv, CellSurfDiffAv < 0, 0), # treat every negative cell surface area difference as 0 == no change to increase positive peak size
         CellSurfDiffAv = replace(CellSurfDiffAv, is.na(CellSurfDiffAv), 0),
         CellSurfDiffAv = replace(CellSurfDiffAv, is.infinite(CellSurfDiffAv), 0),
         CellSurfDiffAv = replace(CellSurfDiffAv, is.nan(CellSurfDiffAv), 0),
         StNCellSurf = mean(CellSurfDiffAv, na.rm = TRUE)/sd(CellSurfDiffAv, na.rm = TRUE), #signal to noise calculation cell surface difference
         StNcc = mean(CCDiffAv, na.rm = TRUE)/sd(CCDiffAv, na.rm = TRUE) #signal to noise calculation cell count difference
         ) %>%  
    mutate(sink_hour = datetime + minutes(ElapMinAv),
         GroupID = cur_group_id(),
         sink_hour = replace(sink_hour, is.na(sink_hour), datetime))

opt_bpts <- function(x) {
  #x = bpts_sum$RSS["BIC",]
  n <- length(x)
  lowest <- vector("logical", length = n-1)
  lowest[1] <- FALSE
  for (i in 2:n) {
    lowest[i] <- x[i] < x[i-1] & x[i] < x[i+1]
  }
  out <- as.integer(names(x)[lowest])
  return(out)
} #https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/

TS_brks <- SinkAll %>%
  ungroup() %>%
  select(GroupID, CCDiffAv, sink_hour) %>%
  arrange(GroupID) %>%
  group_by(GroupID) %>% nest() %>%
  mutate(ts = map(.x = data, 
                  .f = tk_ts, 
                  select = -sink_hour),
         bp_ts = map(ts, ~breakpoints(formula = CCDiffAv ~ 1, data = .)),
         bpts_sum = map(bp_ts, ~summary(.x)),
         opt_brks = map(bpts_sum, ~opt_bpts(.x$RSS["BIC",]))) %>%
  unnest_wider(opt_brks) %>%
  rename("opt_brks" = "...1") %>%
  mutate(opt_brks = replace(opt_brks, is.na(opt_brks), 0)) 

 
Mbrk = matrix(data = NA, nrow = nrow(TS_brks), ncol = 5)
for (i in 1:nrow(TS_brks)){
  Mbrk[i,1] = i # column 1is Group ID
}


  for (i in 1:nrow(TS_brks)){
      for (j in 1:length(TS_brks[[4]][[i]][["breakpoints"]])) {
        Mbrk[i,j+1] <- TS_brks[[4]][[i]][["breakpoints"]][[j]]
      }
  } #for-loop code by Rahel

df_brkpt <- as.data.frame(Mbrk) %>%
  rename("GroupID" = "V1", "Brkpt_1" = "V2", "Brkpt_2" = "V3", "Brkpt_3" = "V4", "Brkpt_4" = "V5") %>% 
  pivot_longer(cols = c(Brkpt_1:Brkpt_4), values_to = "TimeID", names_to = "BrkptNo")%>%
  drop_na() 



Brk_Compare <- full_join(SinkAll, df_brkpt) %>%
  arrange(GroupID) %>%
  mutate(BrkTime = case_when(BrkptNo != "NA" ~ ElapMinAv*1),
         BrkTime = replace(BrkTime, BrkTime == 0, NA),
         CCDiffNoNoise = case_when(CCDiffAv <= StNcc ~ 0,
                                   CCDiffAv > StNcc ~ (CCDiffAv*1)
                                   ),
         CCDiffNoNoise = replace(CCDiffNoNoise, CCDiffNoNoise == 0, NA))
  

#MinFilter <- 120
Y_var <- "CCDiffAv"

CyanoSinkAll <- Brk_Compare %>%
  #filter(date_sink == "2022-10-16") %>%
  filter(strain %in% c("CCMP495", "CCMP1335", "CCMP1336")) %>%
  #filter(ElapMinAv < MinFilter) %>%
  #filter(strain %in% c("PCC6803", "CZS25K", "CCMP836")) %>%
  ggplot() +
  geom_line(aes(y = (!!sym(Y_var)), x = ElapMinAv, color = as.factor(date_sink))) +
  #geom_point(aes(y = (CCDiffNoNoise), x = ElapMinAv, color = "red")) +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  #geom_vline(aes(xintercept = CCDiffNoNoise)) +
  geom_vline(aes(xintercept = BrkTime, color = as.factor(date_sink))) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  coord_cartesian(xlim = c(0, 610)
                  #, ylim = c(0, 4)
                  ) +
  theme_bw()

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project, Y_var, "DiatomSinkAllPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = CyanoSinkAll, height = 10, width = 12)

```



``` {r Grabbelkiste}

CellSurfDiffAv = (TCAreaAv-lag(TCAreaAv))/(CCAv-lag(CCAv)), # create change in cell surface area between time points
         CellSurfDiffAv = replace(CellSurfDiffAv, CellSurfDiffAv < 0, 0), # treat every negative cell surface area difference as 0 == no change to increase positive peak size
         CellSurfDiffAv = replace(CellSurfDiffAv, is.na(CellSurfDiffAv), 0),
         CellSurfDiffAv = replace(CellSurfDiffAv, is.infinite(CellSurfDiffAv), 0),
         CellSurfDiffAv = replace(CellSurfDiffAv, is.nan(CellSurfDiffAv), 0),
         TCAreaDiffAv = (TCAreaAv-lag(TCAreaAv)), # create change in cell surface area between time points
         TCAreaDiffAv = replace(TCAreaDiffAv, TCAreaDiffAv < 0, 0), # treat every negative cell surface area difference as 0 == no change to increase positive peak size
         TCAreaDiffAv = replace(TCAreaDiffAv, is.na(TCAreaDiffAv), 0),
         StNCellSurf = mean(CellSurfDiffAv, na.rm = TRUE)/sd(CellSurfDiffAv, na.rm = TRUE), #signal to noise calculation cell surface difference
         StNcc = mean(CCDiffAv, na.rm = TRUE)/sd(CCDiffAv, na.rm = TRUE) #signal to noise calculation cell count difference

# TS_test <- SinkAll %>%
#   ungroup() %>%
#   select(GroupID, CCDiffAv, sink_hour) %>%
#   inner_join(TS_brks) %>%
#   arrange(GroupID) %>%
#   group_by(GroupID) %>% nest() #%>%
#   mutate(TS_chngpt = map(data, ~cpt.meanvar(data = ., method = "PELT", Q = .$data["opt_brks",])))

SinkReplTotAreaAv <- ImportSink %>%
  group_by(strain, date_sink, datetime, par_ue, ElapMin, TimeID) %>%
  mutate(ReplicateNo = cur_group_id(), 
         TotalCellArea = replace(TotalCellArea, is.na(TotalCellArea), 0) # replace NA with 0, as nothing was detected
         ) %>%
  group_by(ReplicateNo, strain, date_sink, datetime, par_ue, ElapMin, TimeID) %>%
  summarise(TotalCellArea_repl = mean(TotalCellArea, na.rm = TRUE)
            ) 

p1 <- SinkAll %>%
  filter(date_sink == "2022-10-18") %>%
  #filter(strain %in% c("CCMP495")) %>%
  filter(id == "MaBe4066") %>%
  mutate(CCDiffAv = CCDiffAv/max(CCDiffAv),
         CellSurfDiffAv = CellSurfDiffAv/max(CellSurfDiffAv))
p1 %>%
  #filter(strain %in% c("PCC6803", "CZS25K", "CCMP836")) %>%
  ggplot() +
  geom_line(aes(y = (CCDiffAv), x = ElapMinAv, color = "red"), p1) +
  geom_line(aes(y = (CellSurfDiffAv), x = ElapMinAv), p1) +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  #geom_hline(aes(yintercept = StNcc)) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  #ylim(0, 1000) +
  theme_bw()


SinkAll %>%
  filter(date_sink == "2022-10-18") %>%
  #filter(strain %in% c("CCMP495")) %>%
  filter(id == "MaBe4066") %>%
  #filter(strain %in% c("PCC6803", "CZS25K", "CCMP836")) %>%
  ggplot(aes(y = (CCDiffAv), x = ElapMinAv, color = as.factor(well))) +
  geom_line() +
  geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  geom_hline(aes(yintercept = StNcc)) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  #ylim(0, 1000) +
  theme_bw()

SinkAll %>%
  filter(date_sink == "2022-10-18") %>%
  #filter(strain %in% c("CCMP495")) %>%
  filter(id == "MaBe4066") %>%
  #filter(strain %in% c("PCC6803", "CZS25K", "CCMP836")) %>%
  ggplot(aes(y = (CellSurfDiffAv), x = ElapMinAv, color = as.factor(well))) +
  geom_line() +
  geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  geom_hline(aes(yintercept = StNCellSurf)) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  #ylim(0, 1000) +
  theme_bw()

%>% 
  group_by(id) %>%
  mutate(cellcount = replace(cellcount, is.na(cellcount), 0),
         TotalCellArea = replace(TotalCellArea, is.na(TotalCellArea), 0),
         CellMean = rollmean(cellcount, k = 3, fill = NA),
         TotCellAreaMean = rollmean(TotalCellArea, k = 3, fill = NA)) %>%
  #drop_na(cellcount) %>%
  mutate(sink_diff = cellcount - cellcount[1],
         cell_diff = cellcount-lag(cellcount),
         CellSurface = abs(TotalCellArea-lag(TotalCellArea))/abs(cellcount-lag(cellcount)),
         CellDiffMean = CellMean-lag(CellMean),
         CellSurfaceMean = abs(TotCellAreaMean-lag(TotCellAreaMean))/abs(CellMean-lag(CellMean)),
         SurfDiff = abs(TotalCellArea-lag(TotalCellArea)))

##### linear model for detrending
lm2 <- function(data, ...) {  
    eval( rlang::expr(lm(data=!!rlang::enexpr(data), !!!list(...))) ) }

detrendTest <- SinkMetaAll2 %>%
  filter(date_sink == "2022-10-18",
         id %in% c("MaBe4065", "MaBe4066", "MaBe4067", "MaBe4068")) %>%
  group_by(id, date_sink) %>%
  mutate(sink_hour = datetime + minutes(ElapMin),
         CellSurface = replace(CellSurface, is.na(CellSurface), 0),
         CellSurface = replace(CellSurface, is.infinite(CellSurface), 0),
         CellSurface = replace(CellSurface, is.nan(CellSurface), 0)
  ) %>%
  select(-c(CellAverageIntegratedIntensity, CellTotalIntegratedIntensity)) %>%
  nest(seg_data = c(ElapSec, well_target,ElapMin, TimeID, ElapHour, cellcount, Elapsed.Time.m, CellAverageIntensity, CellTotalIntensity, TotalCellArea, AverageCellArea, sink_hour, sink_diff, CellSurface, cell_diff, SurfDiff, CellMean:CellSurfaceMean)) %>%
  mutate(fit_lm = map(seg_data, lm2, CellSurface ~ ElapMin), 
         param_lm = map(fit_lm, tidy),
         pred_lm = map(fit_lm, augment),
         qual_lm = map(fit_lm, glance)) %>%
  unnest(seg_data) %>%
  unnest(param_lm) %>%
  select(-c('std.error', 'statistic', 'p.value')) %>%
  pivot_wider(names_from = term, values_from = estimate, names_prefix = "lm", names_sep = "_") %>%
  rename("lm_intercept" = "lm(Intercept)", "lm_ElapMin" = "lmElapMin") %>%
  mutate(estimate_CellSurf = lm_ElapMin*ElapMin+lm_intercept,
         detrendCellSurf = CellSurface - estimate_CellSurf)

detrendTestPlot <- detrendTest %>%
  mutate(doublediff = detrendCellSurf - estimate_CellSurf) %>%
  ggplot(aes(y = (detrendCellSurf), x = ElapMin, color = as.factor(well))) +
  geom_line() +
  geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  facet_grid(
   # rows = vars(id),
    cols = vars(id)
    ) +
  #ylim(0, 1000) +
  theme_bw()
detrendTestPlot
ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project,"detrendCellSurfPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = detrendTestPlot, height = 10, width = 12)

AvCellSurf <- SinkMetaAll2 %>%
  group_by(strain, par_ue, date_sink, ElapMin) %>%
  summarise(across(c(cellcount, AverageCellArea, TotCellAreaMean), mean, na.rm=TRUE)) 

for (k_size in c(3, 4, 5, 6)) {

  CellMean <- paste("k_result", k_size, sep = "_")

  AvCellSurf <- AvCellSurf %>%
    mutate(!!sym(CellMean) := rollmean(cellcount, k = k_size, fill = NA))
}
#https://stackoverflow.com/questions/55940655/how-to-mutate-for-loop-in-dplyr

SelectStrain <- "CCMP1335" #"CCMP1335", "CCMP1336","PCC6803", "CZS25K", "CCMP836"

AvCellSurfPlot <- AvCellSurf %>%
  pivot_longer(cols = c(k_result_3:k_result_6), names_to = "k_size", values_to = "CellMean_k") %>%
  #filter(k_size != "k_result_1") %>%
  group_by(strain, par_ue, date_sink, k_size) %>%
  mutate(CellDiffMean = CellMean_k-lag(CellMean_k),
         CellSurfaceMean = abs(TotCellAreaMean-lag(TotCellAreaMean))/abs(CellMean_k-lag(CellMean_k)),
         test = AverageCellArea/CellDiffMean) %>%
  filter(CellSurfaceMean < 500) %>%
  filter(date_sink == "2022-10-21") %>%
  filter(strain %in% SelectStrain) %>%
  #filter(strain %in% c(#"CCMP495", "CCMP1335", "CCMP1336")) %>%
  #filter(strain %in% c("PCC6803", "CZS25K", "CCMP836")) %>%
  ggplot(aes(x = (ElapMin), y = (CellSurfaceMean), color = as.factor(k_size))) +
  geom_line() +
  #geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  #coord_cartesian(ylim = c(0, 10)) +
  #ylim(0, 2000) +
  theme_bw()

AvCellSurfPlot

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project,SelectStrain, "AvCellSurfPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = AvCellSurfPlot, height = 10, width = 12)

# detrendAvCellSurf <- AvCellSurf %>%
#   pivot_longer(cols = c(k_result_3:k_result_6), names_to = "k_size", values_to = "CellMean_k") %>%
#   #filter(k_size != "k_result_1") %>%
#   group_by(strain, par_ue, date_sink, k_size) %>%
#   mutate(CellDiffMean = CellMean_k-lag(CellMean_k),
#          CellSurfaceMean = abs(TotCellAreaMean-lag(TotCellAreaMean))/abs(CellMean_k-lag(CellMean_k)),
#          test = AverageCellArea/CellDiffMean) %>%
#   select(strain, date_sink, ElapMin, CellSurfaceMean) 
# 
# z <- read.zoo(detrendAvCellSurf, split = 6, index = 4)
# 
# detrAvCellSurf_ts = zoo::ts()

SinkMetaAll2 %>%
  filter(date_sink == "2022-10-17") %>%
  filter(strain %in% c("CCMP495", "CCMP1335", "CCMP1336")) %>%
  #filter(strain %in% c("PCC6803", "CZS25K", "CCMP836")) %>%
  ggplot(aes(y = log(CellSurface), x = ElapMin, color = as.factor(well))) +
  geom_point() +
  geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
  facet_grid(
    rows = vars(par_ue),
    cols = vars(strain)
    ) +
  #ylim(0, 1000) +
  theme_bw()

TStest <- SinkMetaAll2 %>%
  filter(date_sink == "2022-10-18",
         id %in% c("MaBe4065", "MaBe4066", "MaBe4067", "MaBe4068")) %>%
  group_by(id, date_sink) %>%
  mutate(sink_hour = datetime + minutes(ElapMin),
         TotalAreaDiff = (TotalCellArea-lag(TotalCellArea)),
         TotalCellDiff = (cellcount-lag(cellcount)),
         CellSurface = replace(CellSurface, is.na(CellSurface), 0),
         CellSurface = replace(CellSurface, is.infinite(CellSurface), 0),
         CellSurface = replace(CellSurface, is.nan(CellSurface), 0)
  )

ExportToy <- SinkReplCCAv %>%
  dplyr::filter(date_sink == "2022-10-18",
         strain == "CZS25K",
         par_ue == 100) %>%
  select(ElapMin, DeadCC_repl, AliveCC_repl, DeadAliveCC_repl)

h5write(ExportToy, "ExportToy_sink.h5", name = "CZS25K")

plot(as.ts(decompose_beer$seasonal))
plot(as.ts(decompose_beer$trend))
plot(as.ts(decompose_beer$random))
plot(decompose_beer)
  
test <- SinkMetaAll2 %>%
  filter(date_sink == "2022-10-18",
         id %in% c("MaBe4065", "MaBe4066", "MaBe4067", "MaBe4068")) %>%
  group_by(id, date_sink) %>%
  mutate(sink_hour = datetime + minutes(ElapMin),
         TotalAreaDiff = (TotalCellArea-lag(TotalCellArea)),
         TotalCellDiff = (cellcount-lag(cellcount)),
         CellSurface = replace(CellSurface, is.na(CellSurface), 0),
         CellSurface = replace(CellSurface, is.infinite(CellSurface), 0),
         CellSurface = replace(CellSurface, is.nan(CellSurface), 0),
         normCellSurf = CellSurface/max(CellSurface),
         SignToNoise = mean(normCellSurf, na.rm = TRUE)/sd(normCellSurf, na.rm = TRUE)
  )

test %>% 
  ggplot() +
  geom_line(aes(x = ElapMin, y = normCellSurf, color = as.factor(id))) + 
  geom_hline(aes(yintercept = SignToNoise)) +
  facet_wrap(~ id) +
  theme_bw()

for (k_size in c(2, 3, 4, 5, 6)) {

  RollNormCellSurf <- paste("RollNormCellSurf_k", k_size, sep = "_")

  test <- test %>% 
    mutate(!!sym(RollNormCellSurf) := rollmean(normCellSurf, k = k_size, fill = NA))

}

RollTest <- test %>%
  pivot_longer(cols = c(RollNormCellSurf_k_2:RollNormCellSurf_k_6), names_to = "k_size", values_to = "RollNormCellSurf")

testtest <- RollTest %>%
  group_by(id, date_sink, k_size) %>%
  mutate(SignToNoise = mean(RollNormCellSurf, na.rm = TRUE)/sd(RollNormCellSurf, na.rm = TRUE)) %>%
  ggplot() +
  geom_line(aes(x = ElapMin, y = RollNormCellSurf, color = as.factor(k_size))) + 
  #geom_hline(aes(yintercept = SignToNoise, colour = as.factor(k_size))) +
  facet_wrap(~ id) +
  theme_bw()
testtest

FinalTest <- test

for (k_size in c(2, 3, 4, 5, 6)) {
  
RollCellcount <- paste("RollCellcount_k", k_size, sep = "_")

FinalTest <- FinalTest %>%
  mutate(!!sym(RollCellcount) := rollmean(cellcount, k = k_size, fill = NA))

RollTotalArea <- paste("RollTotalArea_k", k_size, sep = "_")

FinalTest <- FinalTest %>%
  mutate(!!sym(RollTotalArea) := rollmean(TotalCellArea, k = k_size, fill = NA))
}

FinalTest <- FinalTest %>%
  mutate(CellSurface_k2 = abs(RollTotalArea_k_2-lag(RollTotalArea_k_2))/abs(RollCellcount_k_2-lag(RollCellcount_k_2)),
         CellSurface_k3 = abs(RollTotalArea_k_3-lag(RollTotalArea_k_3))/abs(RollCellcount_k_3-lag(RollCellcount_k_3)),
         CellSurface_k4 = abs(RollTotalArea_k_4-lag(RollTotalArea_k_4))/abs(RollCellcount_k_4-lag(RollCellcount_k_4)),
         CellSurface_k5 = abs(RollTotalArea_k_5-lag(RollTotalArea_k_5))/abs(RollCellcount_k_5-lag(RollCellcount_k_5)),
         CellSurface_k6 = abs(RollTotalArea_k_6-lag(RollTotalArea_k_6))/abs(RollCellcount_k_6-lag(RollCellcount_k_6)),
         ) %>%
  pivot_longer(cols= c(CellSurface_k2:CellSurface_k6), names_to = "k_size", values_to = "RollCellSurface") %>%
  group_by(id, date_sink, k_size) %>%
  mutate(RollCellSurface = replace(RollCellSurface, is.na(RollCellSurface), 0),
         RollCellSurface = replace(RollCellSurface, is.infinite(RollCellSurface), 0),
         RollCellSurface = replace(RollCellSurface, is.nan(RollCellSurface), 0),
         normRollCellSurf = RollCellSurface/max(RollCellSurface),
         SignToNoise = mean(normRollCellSurf, na.rm = TRUE)/sd(normRollCellSurf, na.rm = TRUE))

Finaltesttest <- FinalTest %>%
  #filter(k_size == "CellSurface_k6") %>%
  ggplot() +
  geom_line(aes(x = ElapMin, y = normRollCellSurf, color = as.factor(k_size))) + 
  geom_hline(aes(yintercept = SignToNoise, colour = as.factor(k_size))) +
  facet_wrap(~ id) +
  theme_bw()
Finaltesttest

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project,"NormRollCellSurfPlot.png", sep = "_"), fsep = .Platform$file.sep), plot = Finaltesttest, height = 10, width = 12)

##### timetk package approach  
  #select(id, date_sink, CellSurface, sink_hour) %>% 
  tk_anomaly_diagnostics(sink_hour, CellSurface, .frequency = 2)

# test %>%
#   group_by(id, date_sink) %>%
#   plot_anomaly_diagnostics(sink_hour, observed,
#                              .message = FALSE,
#                              .facet_ncol = 2,
#                              .ribbon_alpha = 0.25,
#                              .interactive = FALSE)

```



```{r}


lm2 <- function(data, ...) {  
    eval( rlang::expr(lm(data=!!rlang::enexpr(data), !!!list(...))) ) } #https://stackoverflow.com/questions/58525603/error-using-segmented-with-lm-extracted-from-output-of-tidyverse-map-in-r ; lm2 misses {} in the original answer

glm2 <- function(.df, ...) {
  eval(rlang::expr(glm(!!rlang::enexpr(.df),!!!list(...)))) }
#https://stackoverflow.com/questions/57319130/purrrmap-and-glm-issues-with-call/57528229

formul  = ElapMin ~ cellcount

    
SinkSegm <- SinkMetaAll2 %>%
  mutate(DateTime = paste(date_sink, Elapsed.Time.m)) %>%
  mutate(DateTime = ymd_hms(DateTime)) %>%
  drop_na("DateTime") %>%
  filter(date_sink != "2022-10-21") %>%
  select(-c(CellAverageIntegratedIntensity, CellTotalIntegratedIntensity)) %>%
  nest(seg_data = c(ElapSec, well_target,ElapMin, TimeID, ElapHour, cellcount, Elapsed.Time.m, CellAverageIntensity, CellTotalIntensity, TotalCellArea, AverageCellArea, DateTime, sink_diff, CellSurface, cell_diff, SurfDiff, CellMean:CellSurfaceMean)) %>%
  mutate(fit_lm = map(seg_data, lm2, cellcount ~ ElapMin),
         #            param_lm = map(fit_lm, tidy),
         #            pred_lm = map(fit_lm, augment),
         #            qual_lm = map(fit_lm, glance),
         # fit_qp = map(data, glm2, formula = formul , family = quasipoisson(link = "log")),
         #            param_qp = map(fit_qp, tidy),
         #            pred_qp = map(fit_qp, augment),
         #            qual_qp = map(fit_qp, glance),
       fit_seg_lm = map(fit_lm, segmented, seg.Z = ~ElapMin, npsi = 1),
                    # summary_segmented = map(fit_seg_lm, summary), 
                    coef_seg = map(fit_seg_lm, ~coef.segmented(.x, include.psi = TRUE)),
                    list_coef = map(coef_seg, as.list),
                    tibble_coef = map(list_coef, as_tibble)) %>% 
  unnest(c(tibble_coef)) %>% #https://stackoverflow.com/questions/51181888/r-extracting-model-coefficients-from-a-nested-list-list-columns
  rename(ElapMin_Seg = ElapMin) %>%
  unnest(seg_data) %>%
  select(-fit_lm) 

SinkSect <- SinkSegm %>%
  group_by(id, date_sink) %>%
  mutate(BP_sect = case_when(ElapMin <= psi1.ElapMin ~ "BP_sec1",
                            (psi1.ElapMin < ElapMin) ~ "BP_sec2",
                            #& (psi2.ElapMin > ElapMin) ~ "BP_sec2",
                             #psi2.ElapMin < ElapMin ~ "BP_sec3",
                            TRUE ~ "no_bp"),
         diffSizeTot = min(AverageCellArea) - max(AverageCellArea)) %>%
  group_by(id, date_sink, BP_sect) %>%
  mutate(sink_time = max(ElapMin) - min(ElapMin),
         sink_vel_mm_min = sink_height_mm/sink_time) %>% 
  nest(bp_data = c(ElapMin, cellcount, Elapsed.Time.m, CellAverageIntensity, CellTotalIntensity, TotalCellArea, AverageCellArea, DateTime)) %>%
  mutate(fit_seg = map(bp_data, lm2, cellcount ~ ElapMin), 
         sum_seg = map(fit_seg, summary),
         bp_data = map(.x = bp_data, .f = ~mutate(.x, (min(AverageCellArea) - max(AverageCellArea))))) %>%
  unnest(bp_data) %>%
  rename(diffSizeBP = "(min(AverageCellArea) - max(AverageCellArea))")
  

SinkPlot <- SinkSect %>% 
  filter(BP_sect %in% c("BP_sec1", "no_bp")) %>%
  #filter(strain %in% c("NIES981", "CCMP1333", "CCMP836")) %>%
  #filter(strain %in% c("CCMP495", "CCMP1335", "CCMP1336")) %>%
  filter(par_ue != "NA") %>%
  #filter(par_ue == "300") %>%
  ggplot() +
  #ggtitle("Plot of Diaton, CCMP495") +
  ylab("Sinking velocity mm/min") +
  xlab("Elapsed day") +
  labs(color = "PAR (µE)") +
  geom_point(aes(x = ElapDay, y = log(sink_vel_mm_min), color = as.factor(BP_sect))) +
  #ylim(0, 0.3) +
  #scale_y_continuous(trans = "reverse") + #reverses the y-axis
  facet_grid(rows = vars(strain), cols = vars(par_ue)) +
  theme_bw()

SinkPlot

ggsave(filename = file.path(paste(FP1, FP1, PlotFolder, sep = "/"), paste(Project,"SinkVelocity_Test.png", sep = "_"), fsep = .Platform$file.sep), plot = SinkPlot, height = 10, width = 12)




```

#Plots of all strains for all dates of measurements besides the start date.

#Cyanobacteria plots 
```{r}

SinkMetaAll2 %>% 
  #filter(!date_sink == "2021-02-20") %>%
  filter(strain == "CCMP1333") %>%
  filter(!well_target == "B3") %>%
  filter(!well_target == "B6") %>%
  filter(!well_target == "B7") %>%
  filter(!well_target == "B8") %>%
  filter(!well_target == "B9") %>%
  drop_na("par_ue") %>%
  ggplot() + 
  ggtitle("Plot of Cyanobacteria, CCMP1333") +
  ylab("Cell Count per ml") +
  xlab("Elapsed Time (min)") +
  labs(color = "Dates of measurement") +
  geom_point(aes(x = ElapMin, y = (AverageCellArea), color = as.factor(datetime))) +
  #scale_y_continuous(trans = "reverse") + #reverses the y-axis
  facet_grid (cols = vars(par_ue)) +
  theme_classic()

SinkMetaAll2 %>% 
  #filter(!date_sink == "2021-02-20") %>%
  filter(strain == "CCMP836") %>%
  filter(!well_target == "C3") %>%
  filter(!well_target == "C6") %>%
  filter(!well_target == "C7") %>%
  filter(!well_target == "C8") %>%
  filter(!well_target == "C10") %>%
  drop_na("par_ue") %>%
  ggplot() + 
  ggtitle("Plot of Cyanobacteria, CCMP836") +
  ylab("Cell Count per ml") +
  xlab("Elapsed Time (min)") +
  labs(color = "Dates of measurement") +
  geom_point(aes(x = ElapMin, y = AverageCellArea, color = as.factor(datetime))) +
  #scale_y_continuous(trans = "reverse") + #reverses the y-axis
  facet_grid (cols = vars(par_ue)) +
  theme_classic()

SinkMetaAll2 %>% 
  #filter(!date_sink == "2021-02-20") %>%
  filter(strain == "NIES981") %>%
  filter(!well_target == "D3") %>%
  filter(!well_target == "D6") %>%
  filter(!well_target == "D7") %>%
  filter(!well_target == "D8") %>%
  filter(!well_target == "D10") %>%
  drop_na("par_ue") %>%
  ggplot() + 
  ggtitle("Plot of Cyanobacteria, NIES981") +
  ylab("Cell Count per ml") +
  xlab("Elapsed Time (min)") +
  labs(color = "Dates of measurement") +
  geom_point(aes(x = ElapMin, y = AverageCellArea, color = as.factor(datetime))) +
  #scale_y_continuous(trans = "reverse") + #reverses the y-axis
  facet_grid (cols = vars(par_ue)) +
  theme_classic()

```

#Diatom plots

```{r}

SinkMetaAll2 %>% 
  filter(!date_sink == "2021-02-17") %>%
  filter(strain == "CCMP1336") %>%
  filter(!well_target == "G3") %>%
  filter(!well_target == "G6") %>%
  filter(!well_target =="G5") %>%
  filter(!well_target == "G8") %>%
  filter(!well_target == "G10") %>%
  drop_na("par_ue") %>%
  ggplot() +
  ggtitle("Plot of Diaton, CCMP1336") +
  ylab("Cell Count per ml") +
  xlab("Elapsed Time (min)") +
  labs(color = "Dates of Measurement") +
  geom_point(aes(x = ElapMin, y = cellcount, color = as.factor(datetime))) +
  scale_y_continuous(trans = "reverse") + #reverses the y-axis
  facet_grid (cols = vars(par_ue)) +
  theme_classic()

SinkMetaAll2 %>% 
  filter(!date_sink == "2021-02-17") %>%
  filter(strain == "CCMP1335") %>%
  filter(!well_target == "F3") %>%
  filter(!well_target == "F6") %>%
  filter(!well_target =="F5") %>%
  filter(!well_target == "F8") %>%
  filter(!well_target == "F10") %>%
  #filter(par_ue == 300) %>%
  drop_na("par_ue") %>%
  ggplot() +
  ggtitle("Plot of Diaton, CCMP1335") +
  ylab("Cell Count per ml") +
  xlab("Elapsed Time (min)") +
  labs(color = "Dates of Measurement") +
  theme_classic() +
  geom_point(aes(x = ElapMin, y = cellcount, color = as.factor(datetime))) +
  scale_y_continuous(trans = "reverse") #+ #reverses the y-axis
  facet_grid (cols = vars(par_ue)) 
  

SinkMetaAll2 %>% 
  filter(!date_sink == "2021-02-17") %>%
  filter(strain == "CCMP495") %>%
  filter(!well_target == "E3") %>%
  filter(!well_target == "E6") %>%
  filter(!well_target =="E5") %>%
  filter(!well_target == "E8") %>%
  filter(!well_target == "E10") %>%
  drop_na("par_ue") %>%
  ggplot() +
  ggtitle("Plot of Diaton, CCMP495") +
  ylab("Cell Count per ml") +
  xlab("Elapsed Time (min)") +
  labs(color = "Dates of Measurement") +
  geom_point(aes(x = ElapMin, y = cellcount, color = as.factor(datetime))) +
  scale_y_continuous(trans = "reverse") + #reverses the y-axis
  facet_grid (cols = vars(par_ue)) +
  theme_classic()


```

```{r}

# SinkNest <- SinkMetaAll2 %>%
#   select(date_sink, Elapsed.Time.m, cellcount, well_target, strain, well) %>%
#   mutate(DateTime = paste(date_sink, Elapsed.Time.m)) %>%
#   mutate(DateTime = ymd_hms(DateTime)) %>%
#   drop_na("DateTime") %>%
#   select(-Elapsed.Time.m) %>%
#   relocate(DateTime, .before =  cellcount, date_sink, well_target, well, strain)
# 
# SinkXTS <-  xts(SinkNest$cellcount, SinkNest$DateTime)
# SinkTS <- ts(as.numeric(SinkXTS), frequency = 10)
# 
#   relocate(DateTime, .before = cellcount) %>%
#   nest(data = c(DateTime, cellcount)) %>%
#   mutate(xts_data = map(data, ~as.xts(.x$DateTime)))
#   mutate(xts_data = map(data, ~xts(order.by =  .x$DateTime))) %>%
#   mutate(data_ts = map(xts_data, ~ts(as.numeric(.x$xts_data), frequency = 10)))

# SinkBP <- SinkMetaAll2 %>%
#   mutate(DateTime = paste(date_sink, Elapsed.Time.m)) %>%
#   mutate(DateTime = ymd_hms(DateTime)) %>%
#   drop_na("DateTime") %>%
#   select(-c(CellAverageIntegratedIntensity, CellTotalIntegratedIntensity)) %>%
#   nest(data = c(ElapMin, cellcount, Elapsed.Time.m, CellAverageIntensity, CellTotalIntensity, TotalCellArea, AverageCellArea, DateTime)) %>%
#   mutate(fit_bp = map(data, ~breakpoints(cellcount ~ ElapMin, data = ., breaks = 2)),
#                     param_bp = map(fit_bp, "coefficients"),
#                     qual_bp = map(fit_bp, "vcov"),
#                     summary_bp = map(fit_bp, summary))
# 
# 
# SinkChngpt <- SinkMetaAll2 %>%
#   mutate(DateTime = paste(date_sink, Elapsed.Time.m)) %>%
#   mutate(DateTime = ymd_hms(DateTime)) %>%
#   drop_na("DateTime") %>%
#   select(-c(CellAverageIntegratedIntensity, CellTotalIntegratedIntensity)) %>%
#   nest(data = c(ElapMin, cellcount, Elapsed.Time.m, CellAverageIntensity, CellTotalIntensity, TotalCellArea, AverageCellArea, DateTime)) %>%
#   mutate(fit_chngpt = map(data, ~chngptm(formula.1 = cellcount ~ 1, formula.2 = ~ ElapMin, data = ., type = "M22c",  family = "gaussian")),
#                         param_chngpt = map(fit_chngpt, "coefficients"),
#                         qual_chngpt = map(fit_chngpt, "vcov"),
#                         summary_chngpt = map(fit_chngpt, summary))


  

test <- SinkMetaAll2 %>% 
  filter(!date_sink == "2021-02-17") %>%
  filter(strain == "NIES981") %>%
  filter(!well_target == "B3") %>%
  filter(!well_target == "B6") %>%
  filter(!well_target == "B7") %>%
  filter(!well_target == "B8") %>%
  filter(!well_target == "B9") %>%
  filter(par_ue == 30) %>%
  #drop_na("FieldOfView_mm2") %>%
  select(date_sink, Elapsed.Time.m, cellcount) %>%
  mutate(DateTime = paste(date_sink, Elapsed.Time.m)) %>%
  mutate(DateTime = ymd_hms(DateTime)) %>%
  select(-c(Elapsed.Time.m, date_sink)) %>%
  relocate(DateTime, .before = cellcount) %>%
  drop_na("DateTime") 

data_xts <- as.xts(test, order.by = test$DateTime)
data_xts2 <- xts(test$cellcount, test$DateTime)
data_ts <- ts(as.numeric(data_xts2), frequency = 10)

data("Nile")

fs.CCMP1335 <- Fstats(data_ts ~ 1)
plot(fs.CCMP1335)
breakpoints(fs.CCMP1335)
lines(breakpoints(fs.CCMP1335))


bp.CCMP1335 <- breakpoints(data_ts ~ 1)
summary(bp.CCMP1335)

## the BIC also chooses one breakpoint
plot(bp.CCMP1335)
breakpoints(bp.CCMP1335)


fm0 <- lm(data_ts ~ 1)
fm1 <- lm(data_ts ~ breakfactor(bp.CCMP1335, breaks = 1))
plot(data_ts)
lines(ts(fitted(fm0)), col = 3)
lines(ts(fitted(fm1)), col = 4)
lines(bp.CCMP1335)

## confidence interval
ci.nile <- confint(bp.CCMP1335)
ci.nile
lines(ci.nile)
```

